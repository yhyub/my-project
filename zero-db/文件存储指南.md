# ZeroDB 文件存储指南

## 📁 文件存储方式

ZeroDB支持两种文件存储方式：

### 1. 直接存储文件内容（BLOB）
- 将文件内容直接存储在数据库中
- 适合小文件（建议 < 1MB）
- 优点：管理简单，事务支持好
- 缺点：占用数据库空间，影响性能

### 2. 存储文件路径
- 仅在数据库中存储文件路径，实际文件存放在文件系统
- 适合大文件
- 优点：不占用数据库空间，性能好
- 缺点：需要额外管理文件系统

## 🗄️ 表结构设计

### 1. 直接存储文件内容

```sql
CREATE TABLE files (
    file_id INTEGER PRIMARY KEY AUTOINCREMENT,
    filename VARCHAR(255) NOT NULL,
    file_type VARCHAR(50) NOT NULL,
    file_size INTEGER NOT NULL,
    file_content BLOB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_id INTEGER,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

### 2. 存储文件路径

```sql
CREATE TABLE file_paths (
    file_id INTEGER PRIMARY KEY AUTOINCREMENT,
    filename VARCHAR(255) NOT NULL,
    file_type VARCHAR(50) NOT NULL,
    file_size INTEGER NOT NULL,
    file_path VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_id INTEGER,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

### 3. 文件元数据扩展表

```sql
CREATE TABLE file_metadata (
    metadata_id INTEGER PRIMARY KEY AUTOINCREMENT,
    file_id INTEGER,
    metadata_key VARCHAR(50) NOT NULL,
    metadata_value TEXT,
    FOREIGN KEY (file_id) REFERENCES files(file_id)
);
```

## 💾 文件存储示例

### 1. 直接存储文件内容（SQL示例）

```sql
-- 插入文件（需要使用编程语言绑定，直接SQL难以处理BLOB）
-- 以下是伪代码示例
INSERT INTO files (filename, file_type, file_size, file_content, user_id)
VALUES ('test.txt', 'text/plain', 1024, X'5465737420636f6e74656e74', 1);

-- 查询文件
SELECT filename, file_type, file_size, created_at FROM files WHERE file_id = 1;

-- 获取文件内容
SELECT file_content FROM files WHERE file_id = 1;
```

### 2. 存储文件路径（SQL示例）

```sql
-- 插入文件路径
INSERT INTO file_paths (filename, file_type, file_size, file_path, user_id)
VALUES ('test.txt', 'text/plain', 1024, '/data/files/test.txt', 1);

-- 查询文件
SELECT filename, file_type, file_size, file_path FROM file_paths WHERE file_id = 1;
```

## 🐍 Python代码实现

### 1. 安装依赖

```bash
pip install mysql-connector-python
```

### 2. 直接存储文件内容

```python
import mysql.connector
import os
from datetime import datetime

# 连接数据库
cnx = mysql.connector.connect(
    host="127.0.0.1",
    port=3306,
    user="root",
    password="",
    database="test"
)
cursor = cnx.cursor()

# 存储文件到数据库
def store_file_in_db(file_path, user_id=1):
    """将文件存储到数据库中"""
    # 读取文件信息
    filename = os.path.basename(file_path)
    file_size = os.path.getsize(file_path)
    file_type = "application/octet-stream"  # 默认类型
    
    # 根据文件扩展名设置MIME类型
    ext = os.path.splitext(filename)[1].lower()
    mime_types = {
        '.txt': 'text/plain',
        '.md': 'text/markdown',
        '.json': 'application/json',
        '.csv': 'text/csv',
        '.jpg': 'image/jpeg',
        '.png': 'image/png',
        '.gif': 'image/gif',
        '.pdf': 'application/pdf',
        '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    }
    if ext in mime_types:
        file_type = mime_types[ext]
    
    # 读取文件内容
    with open(file_path, 'rb') as f:
        file_content = f.read()
    
    # 插入数据库
    query = """
    INSERT INTO files (filename, file_type, file_size, file_content, user_id)
    VALUES (%s, %s, %s, %s, %s)
    """
    cursor.execute(query, (filename, file_type, file_size, file_content, user_id))
    cnx.commit()
    
    return cursor.lastrowid

# 从数据库读取文件
def read_file_from_db(file_id, output_path):
    """从数据库读取文件并保存到本地"""
    # 查询文件信息
    query = "SELECT filename, file_content FROM files WHERE file_id = %s"
    cursor.execute(query, (file_id,))
    result = cursor.fetchone()
    
    if result:
        filename, file_content = result
        full_path = os.path.join(output_path, filename)
        
        # 保存文件
        with open(full_path, 'wb') as f:
            f.write(file_content)
        
        return full_path
    return None

# 使用示例
if __name__ == "__main__":
    # 存储文件
    file_id = store_file_in_db("test.txt")
    print(f"文件存储成功，ID: {file_id}")
    
    # 读取文件
    output_path = "./output"
    os.makedirs(output_path, exist_ok=True)
    saved_path = read_file_from_db(file_id, output_path)
    print(f"文件读取成功，保存到: {saved_path}")
    
    # 关闭连接
    cursor.close()
    cnx.close()
```

### 3. 存储文件路径

```python
import mysql.connector
import os
import shutil
from datetime import datetime

# 连接数据库
cnx = mysql.connector.connect(
    host="127.0.0.1",
    port=3306,
    user="root",
    password="",
    database="test"
)
cursor = cnx.cursor()

# 文件存储目录
STORAGE_DIR = "./file_storage"
os.makedirs(STORAGE_DIR, exist_ok=True)

# 存储文件路径
def store_file_path(file_path, user_id=1):
    """存储文件路径到数据库"""
    # 复制文件到存储目录
    filename = os.path.basename(file_path)
    dest_path = os.path.join(STORAGE_DIR, filename)
    shutil.copy2(file_path, dest_path)
    
    # 获取文件信息
    file_size = os.path.getsize(dest_path)
    file_type = "application/octet-stream"
    
    # 根据文件扩展名设置MIME类型
    ext = os.path.splitext(filename)[1].lower()
    mime_types = {
        '.txt': 'text/plain',
        '.md': 'text/markdown',
        '.json': 'application/json',
        '.csv': 'text/csv',
        '.jpg': 'image/jpeg',
        '.png': 'image/png',
        '.gif': 'image/gif',
        '.pdf': 'application/pdf'
    }
    if ext in mime_types:
        file_type = mime_types[ext]
    
    # 插入数据库
    query = """
    INSERT INTO file_paths (filename, file_type, file_size, file_path, user_id)
    VALUES (%s, %s, %s, %s, %s)
    """
    cursor.execute(query, (filename, file_type, file_size, dest_path, user_id))
    cnx.commit()
    
    return cursor.lastrowid

# 从数据库获取文件
def get_file_from_path(file_id, output_path="."):
    """从数据库获取文件路径并复制文件"""
    # 查询文件路径
    query = "SELECT filename, file_path FROM file_paths WHERE file_id = %s"
    cursor.execute(query, (file_id,))
    result = cursor.fetchone()
    
    if result:
        filename, file_path = result
        dest_path = os.path.join(output_path, filename)
        
        # 复制文件
        shutil.copy2(file_path, dest_path)
        return dest_path
    return None

# 使用示例
if __name__ == "__main__":
    # 存储文件路径
    file_id = store_file_path("test.txt")
    print(f"文件路径存储成功，ID: {file_id}")
    
    # 获取文件
    saved_path = get_file_from_path(file_id)
    print(f"文件获取成功，保存到: {saved_path}")
    
    # 关闭连接
    cursor.close()
    cnx.close()
```

### 4. 文件元数据管理

```python
# 添加文件元数据
def add_file_metadata(file_id, metadata):
    """添加文件元数据"""
    query = """
    INSERT INTO file_metadata (file_id, metadata_key, metadata_value)
    VALUES (%s, %s, %s)
    """
    
    # 批量插入元数据
    metadata_values = [(file_id, k, str(v)) for k, v in metadata.items()]
    cursor.executemany(query, metadata_values)
    cnx.commit()

# 获取文件元数据
def get_file_metadata(file_id):
    """获取文件元数据"""
    query = """
    SELECT metadata_key, metadata_value
    FROM file_metadata
    WHERE file_id = %s
    """
    cursor.execute(query, (file_id,))
    
    metadata = {}
    for key, value in cursor.fetchall():
        metadata[key] = value
    
    return metadata

# 使用示例
if __name__ == "__main__":
    # 添加元数据
    metadata = {
        "author": "ZeroDB",
        "created_at": datetime.now().isoformat(),
        "version": "1.0",
        "tags": "document,test"
    }
    add_file_metadata(file_id, metadata)
    
    # 获取元数据
    file_metadata = get_file_metadata(file_id)
    print("文件元数据:", file_metadata)
```

## 📊 查询和管理文件

### 1. 查询文件列表

```sql
-- 查询所有文件
SELECT file_id, filename, file_type, file_size, created_at 
FROM files 
ORDER BY created_at DESC;

-- 查询特定用户的文件
SELECT file_id, filename, file_type, file_size, created_at 
FROM files 
WHERE user_id = 1 
ORDER BY created_at DESC;

-- 查询特定类型的文件
SELECT file_id, filename, file_type, file_size, created_at 
FROM files 
WHERE file_type LIKE 'image/%' 
ORDER BY created_at DESC;
```

### 2. 更新文件

```sql
-- 更新文件名
UPDATE files SET filename = 'new_name.txt' WHERE file_id = 1;

-- 更新文件内容（需要Python代码实现）
```

### 3. 删除文件

```sql
-- 删除文件
DELETE FROM files WHERE file_id = 1;

-- 删除文件及元数据
DELETE FROM file_metadata WHERE file_id = 1;
DELETE FROM files WHERE file_id = 1;
```

## 💡 最佳实践

1. **文件大小限制**
   - 直接存储：建议 < 1MB
   - 路径存储：无限制

2. **性能优化**
   - 为常用查询字段创建索引
   - 定期清理过期文件
   - 大文件使用路径存储方式

3. **事务管理**
   - 存储文件和元数据时使用事务
   - 确保数据一致性

4. **安全考虑**
   - 验证文件类型和大小
   - 对敏感文件进行加密
   - 实现访问控制

5. **备份策略**
   - 定期备份数据库
   - 路径存储时同时备份文件系统

## 🚫 限制和注意事项

1. **ZeroDB是轻量级数据库**，不适合存储大量大文件
2. 直接存储文件会增加数据库大小，影响性能
3. 大文件操作可能导致内存占用增加
4. 建议根据文件大小选择合适的存储方式
5. 定期清理不需要的文件，释放资源

## 📁 适用场景

- 存储小型配置文件
- 存储AI生成的文本文件
- 存储用户头像等小型图片
- 存储文档和报告
- 存储临时文件

## 🎯 示例应用场景

### 1. AI生成文件存储

```python
# 存储AI生成的文件
def store_ai_generated_file(content, filename, user_id=1):
    """存储AI生成的文件"""
    # 保存到临时文件
    temp_path = f"./temp_{filename}"
    with open(temp_path, 'w') as f:
        f.write(content)
    
    # 存储到数据库
    file_id = store_file_in_db(temp_path, user_id)
    
    # 删除临时文件
    os.remove(temp_path)
    
    # 添加AI相关元数据
    metadata = {
        "generated_by": "AI",
        "generated_at": datetime.now().isoformat(),
        "type": "ai_generated"
    }
    add_file_metadata(file_id, metadata)
    
    return file_id

# 使用示例
aicontent = "这是AI生成的内容..."
file_id = store_ai_generated_file(aicontent, "ai_output.txt")
print(f"AI生成文件存储成功，ID: {file_id}")
```

### 2. 用户文件管理

```python
# 获取用户文件列表
def get_user_files(user_id, limit=20):
    """获取用户文件列表"""
    query = """
    SELECT file_id, filename, file_type, file_size, created_at
    FROM files
    WHERE user_id = %s
    ORDER BY created_at DESC
    LIMIT %s
    """
    cursor.execute(query, (user_id, limit))
    return cursor.fetchall()

# 使用示例
files = get_user_files(1, limit=10)
for file in files:
    file_id, filename, file_type, file_size, created_at = file
    print(f"ID: {file_id}, 名称: {filename}, 类型: {file_type}, 大小: {file_size} bytes, 时间: {created_at}")
```

## 📞 技术支持

如果您在使用过程中遇到任何问题，欢迎查看 `README.md` 文档或联系技术支持。

---

ZeroDB 让您轻松存储和管理文件数据，享受零占用的高效数据库服务！
